import java.util.List;

import burlap.mdp.auxiliary.DomainGenerator;
import burlap.mdp.core.Domain;
import burlap.mdp.core.StateTransitionProb;
import burlap.mdp.core.TerminalFunction;
import burlap.mdp.core.action.Action;
import burlap.mdp.core.state.State;
import burlap.mdp.singleagent.model.RewardFunction;
import burlap.mdp.singleagent.model.statemodel.FullStateModel;

public class TestBurlap implements DomainGenerator {

	public static final String VAR_X = "x";
	public static final String VAR_Y = "y";
	public static final String ACTION_NORTH = "north";
	public static final String ACTION_SOUTH = "south";
	public static final String ACTION_EAST = "east";
	public static final String ACTION_WEST = "west";

	protected int[][] map = new int[][] { { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
			{ 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 },
			{ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, };

	@Override
	public Domain generateDomain() {
		// TODO Auto-generated method stub
		return null;
	}

	protected class GridStateModel implements FullStateModel {

		protected double[][] transitionProbs;

		public GridStateModel() {
			this.transitionProbs = new double[4][4];
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					double p = i != j ? 0.2 / 3 : 0.8;
					transitionProbs[i][j] = p;
				}
			}
		}

		@Override
		public State sample(State arg0, Action arg1) {
			return null;
		}

		@Override
		public List<StateTransitionProb> stateTransitions(State arg0,
				Action arg1) {
			return null;
		}
		
		protected int [] moveResult(int curX, int curY, int direction){

			//first get change in x and y from direction using 0: north; 1: south; 2:east; 3: west
			int xdelta = 0;
			int ydelta = 0;
			if(direction == 0){
				ydelta = 1;
			}
			else if(direction == 1){
				ydelta = -1;
			}
			else if(direction == 2){
				xdelta = 1;
			}
			else{
				xdelta = -1;
			}

			int nx = curX + xdelta;
			int ny = curY + ydelta;

			int width = ExampleGridWorld.this.map.length;
			int height = ExampleGridWorld.this.map[0].length;

			//make sure new position is valid (not a wall or off bounds)
			if(nx < 0 || nx >= width || ny < 0 || ny >= height ||
					ExampleGridWorld.this.map[nx][ny] == 1){
				nx = curX;
				ny = curY;
			}


			return new int[]{nx,ny};

		}

		protected int actionDir(Action a) {
			int adir = -1;
			if (a.actionName().equals(ACTION_NORTH)) {
				adir = 0;
			} else if (a.actionName().equals(ACTION_SOUTH)) {
				adir = 1;
			} else if (a.actionName().equals(ACTION_EAST)) {
				adir = 2;
			} else if (a.actionName().equals(ACTION_WEST)) {
				adir = 3;
			}
			return adir;
		}

	}

	protected class GridRewardModel implements RewardFunction {

		@Override
		public double reward(State arg0, Action arg1, State arg2) {
			return 0;
		}

	}

	protected class GridTerminalModel implements TerminalFunction {

		@Override
		public boolean isTerminal(State arg0) {
			return false;
		}

	}

}
