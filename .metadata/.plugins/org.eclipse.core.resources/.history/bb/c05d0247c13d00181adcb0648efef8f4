import ilog.concert.*;
import ilog.cplex.*;

public class ERASER {

	public static void solve() throws IloException {
		// Values of the targets when it covered and uncovered by defender for
		// defender and attacker.
		int targets = 7;
		double[] defCov = { 11.0, 7.0, 14.0, 15.0, 19.0, 16.0, 17.0 };
		double[] defUCov = { -11.0, -7.0, -14.0, -15.0, -19.0, -16.0, -17.0 };
		double[] attCov = { -33.0, -21.0, -42.0, -45.0, -57.0, -48.0, -51.0 };
		double[] attUCov = { 11.0, 7.0, 14.0, 15.0, 19.0, 16.0, 17.0 };
		double[] hours = { 10.0, 2.0, 3.0, 12.0, 5.0, 6.0, 5.0 };

		IloCplex cplex = new IloCplex();
		double Z = Double.MAX_VALUE;
		double B = 25; // Budget: number of hours defender has.

		// Objective value
		double d;

		// Defender coverage vector for targets and Constraints 0 to 1
		IloNumVar[] c = cplex.numVarArray(targets, 0.0, 1.0);

		// Attacker attack vector for targets and Constraints 0 or 1
		IloNumVar[] a = cplex.boolVarArray(targets);

		// Equation gives the defender utility for an attack on target
		// t, given his coverage vector
		IloLinearNumExpr[] exp = new IloLinearNumExpr[targets];
		for (int t = 0; t < targets; t++) {
			
		}
		
		IloLinearNumExpr const2 = cplex.linearNumExpr();
		for (int j = 0; j < mixedAttacker; j++) {
			q[j] = cplex.boolVar();
			const2.addTerm(1.0, q[j]);
		}
		cplex.addEq(const2, 1.0);

		// Equation gives the attacker utility for an attack on target
		// t, given his coverage vector

		// Constraint 1
		cplex.addEq(cplex.sum(a), 1.0);

		// Constraint 2
		cplex.addLe(cplex.scalProd(c, hours), B);

		// Constraint 3

		// Constraint 4

	}
}
