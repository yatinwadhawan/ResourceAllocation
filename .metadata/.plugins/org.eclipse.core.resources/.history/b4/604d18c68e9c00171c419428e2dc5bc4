import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import burlap.behavior.policy.EpsilonGreedy;
import burlap.behavior.policy.Policy;
import burlap.behavior.singleagent.Episode;
import burlap.behavior.singleagent.MDPSolver;
import burlap.behavior.singleagent.learning.LearningAgent;
import burlap.behavior.valuefunction.QFunction;
import burlap.behavior.valuefunction.QProvider;
import burlap.behavior.valuefunction.QValue;
import burlap.mdp.core.action.Action;
import burlap.mdp.core.state.State;
import burlap.mdp.singleagent.SADomain;
import burlap.mdp.singleagent.environment.Environment;
import burlap.statehashing.HashableState;
import burlap.statehashing.HashableStateFactory;

public class QLTutorial extends MDPSolver implements LearningAgent, QProvider {

	Map<HashableState, List<QValue>> qValues;
	QFunction qinit;
	double learningRate;
	Policy learningPolicy;

	public QLTutorial(SADomain domain, double gamma,
			HashableStateFactory hashingFactory, QFunction qinit,
			double learningRate, double epsilon) {

		this.solverInit(domain, gamma, hashingFactory);
		this.qinit = qinit;
		this.learningRate = learningRate;
		this.qValues = new HashMap<HashableState, List<QValue>>();
		this.learningPolicy = new EpsilonGreedy(this, epsilon);

	}

	@Override
	public void resetSolver() {
		// TODO Auto-generated method stub

	}

	@Override
	public double qValue(State s, Action a) {
		return storedQ(s, a).q;
	}

	@Override
	public double value(State s) {
		// TODO Auto-generated method stub
		return QProvider.Helper.maxQ(this, s);
	}

	@Override
	public List<QValue> qValues(State s) {
		// first get hashed state
		HashableState sh = this.hashingFactory.hashState(s);

		// check if we already have stored values
		List<QValue> qs = this.qValues.get(sh);

		// create and add initialized Q-values if we don't have them stored for
		// this state
		if (qs == null) {
			List<Action> actions = this.applicableActions(s);
			qs = new ArrayList<QValue>(actions.size());
			// create a Q-value for each action
			for (Action a : actions) {
				// add q with initialized value
				qs.add(new QValue(s, a, this.qinit.qValue(s, a)));
			}
			// store this for later
			this.qValues.put(sh, qs);
		}

		return qs;
	}

	@Override
	public Episode runLearningEpisode(Environment arg0) {
		// TODO Auto-generated method stub
		return this.runLearningEpisode(env, -1);
	}

	@Override
	public Episode runLearningEpisode(Environment arg0, int arg1) {
		// TODO Auto-generated method stub
		return null;
	}

	protected QValue storedQ(State s, Action a) {
		// first get all Q-values
		List<QValue> qs = this.qValues(s);

		// iterate through stored Q-values to find a match for the input action
		for (QValue q : qs) {
			if (q.a.equals(a)) {
				return q;
			}
		}

		throw new RuntimeException("Could not find matching Q-value.");
	}

}
