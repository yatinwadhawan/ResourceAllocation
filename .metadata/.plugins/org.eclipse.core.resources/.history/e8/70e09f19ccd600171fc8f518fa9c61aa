package AttackerQLearning;

import java.util.ArrayList;
import java.util.List;

import classes.MAction;
import classes.Node;
import classes.NodeStatus;
import classes.WState;
import mainClass.MainClass;
import QLearningDefender.DecisionMaking;
import burlap.mdp.auxiliary.DomainGenerator;
import burlap.mdp.core.Domain;
import burlap.mdp.core.StateTransitionProb;
import burlap.mdp.core.TerminalFunction;
import burlap.mdp.core.action.Action;
import burlap.mdp.core.action.UniversalActionType;
import burlap.mdp.core.state.State;
import burlap.mdp.singleagent.SADomain;
import burlap.mdp.singleagent.model.FactoredModel;
import burlap.mdp.singleagent.model.RewardFunction;
import burlap.mdp.singleagent.model.statemodel.FullStateModel;

public class WorldGeneratorAttacker implements DomainGenerator {

	@Override
	public Domain generateDomain() {

		SADomain domain = new SADomain();
		for (int i = 0; i < MainClass.actionList.size(); i++) {
			domain.addActionType(new UniversalActionType(MainClass.actionList
					.get(i)));
		}

		StateWorldAttacker smodel = new StateWorldAttacker();
		RewardAttacker rf = new RewardAttacker();
		TerminalAttacker tf = new TerminalAttacker();

		domain.setModel(new FactoredModel(smodel, rf, tf));

		return domain;
	}

	protected class StateWorldAttacker implements FullStateModel {

		@Override
		public State sample(State s, Action a) {

			MAction ac = (MAction) a;
			String name = ac.getNodeName();
			String action = ac.getAction();

			State w = s.copy();
			WState state = (WState) w;
			int size = state.getNodeList().size();
			int index = 0;

			// Find the index of the node in the graph on which action is
			// performed.
			for (int i = 0; i < size; i++) {
				if (name.equals(state.getNodeList().get(i).getSymbol())) {
					index = i;
					break;
				}
			}

			Node n = state.getNodeList().get(index);
			if (action.equals(NodeStatus.ACTION_SCAN)) {

				if (n.getStatus().equals(NodeStatus.HACKED)) {
					state.getNodeList().get(index).setStatus(NodeStatus.HACKED);

				} else if (n.getStatus().equals(NodeStatus.UNKNOWN)) {

					// Hacked
					double rand = Math.random();
					if (rand > 0.5) {
						state.getNodeList().get(index)
								.setStatus(NodeStatus.PATCHED);
					} else {
						state.getNodeList().get(index)
								.setStatus(NodeStatus.VULNERABLE);
					}

				} else if (n.getStatus().equals(NodeStatus.VULNERABLE)) {
					state.getNodeList().get(index)
							.setStatus(NodeStatus.VULNERABLE);

				} else {
					// If status is PATCHED
					double rand = Math.random();
					if (rand > 0.5) {
						state.getNodeList().get(index)
								.setStatus(NodeStatus.PATCHED);
					} else {
						state.getNodeList().get(index)
								.setStatus(NodeStatus.VULNERABLE);
					}
				}

			} else {
				// Action is HACK

				if (n.getStatus().equals(NodeStatus.HACKED)) {

					state.getNodeList().get(index).setStatus(NodeStatus.HACKED);

				} else if (n.getStatus().equals(NodeStatus.UNKNOWN)) {
					state.getNodeList().get(index)
							.setStatus(NodeStatus.UNKNOWN);

				} else if (n.getStatus().equals(NodeStatus.VULNERABLE)) {

					state.getNodeList().get(index).setStatus(NodeStatus.HACKED);

				} else {
					// PATCHED
					state.getNodeList().get(index)
							.setStatus(NodeStatus.PATCHED);
				}
			}

			return state;
		}

		@Override
		public List<StateTransitionProb> stateTransitions(State arg0,
				Action arg1) {
			// TODO Auto-generated method stub
			return null;
		}

	}

	protected class RewardAttacker implements RewardFunction {

		@Override
		public double reward(State s, Action a, State sp) {

			int negativereward = -200;
			int fraction = 2;

			// Fill this function
			MAction ac = (MAction) a;
			String namea = ac.getNodeName();
			String action = ac.getAction();

			State w = s.copy();
			WState state = (WState) w;
			int size = state.getNodeList().size();
			Node n = null;

			State wp = sp.copy();
			WState statep = (WState) wp;
			int sizep = statep.getNodeList().size();
			Node np = null;

			// Find the index of the node in the graph on which action is
			// performed.
			for (int i = 0; i < size; i++) {
				if (namea.equals(state.getNodeList().get(i).getSymbol())) {
					n = state.getNodeList().get(i);
					break;
				}
			}
			for (int i = 0; i < sizep; i++) {
				if (namea.equals(statep.getNodeList().get(i).getSymbol())) {
					np = statep.getNodeList().get(i);
					break;
				}
			}

			if (action.equals(NodeStatus.ACTION_SCAN)) {

				if (n.getStatus().equals(NodeStatus.HACKED)) {
					return negativereward;

				} else if (n.getStatus().equals(NodeStatus.VULNERABLE)) {
					return negativereward;
				} else if (n.getStatus().equals(NodeStatus.UNKNOWN)) {
					// We distinguish between the state in which
					// node lands.. whether Vulnerable or Patched

					if (DecisionMaking.isHackedStateInvolved
							&& np.getStatus().equals(NodeStatus.HACKED)) {
						return MainClass.reward.get(np.getName()) * fraction;
					} else if (np.getStatus().equals(NodeStatus.PATCHED)) {
						return 0;
					} else {
						return MainClass.reward.get(np.getName()) * fraction;
					}
				}
			} else {
				// HACK

			}
			return 0;
		}

	}

	protected class TerminalAttacker implements TerminalFunction {

		@Override
		public boolean isTerminal(State s) {

			WState state = (WState) s;
			ArrayList<Node> l = state.getNodeList();
			int size = l.size();
			for (int i = 0; i < size; i++) {
				Node n = l.get(i);
				if (n.getSymbol().equals("S7")) {
					if (n.getStatus().equals(NodeStatus.HACKED))
						return true;
				}
			}
			return false;
		}
	}
}
